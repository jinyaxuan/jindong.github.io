<!DOCTYPE HTML>
<html lang="null">
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="单身程序员的小窝">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content="Machine Learning">


    <meta name="description" content="电影评分的 k 均值聚类假设你是 Netflix 的一名数据分析师，你想要根据用户对不同电影的评分研究用户在电影品位上的相似和不同之处。了解这些评分对用户电影推荐系统有帮助吗？我们来研究下这方面...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>K-Means | 单身程序员的小窝</title>


    <link rel="alternate" href="/atom.xml" title="单身程序员的小窝" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>




    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?4cc1f2d8f3067386cc5cdb626a202900";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    

</head>


</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="Jindong">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                <h2> 活成了一个快乐的小×× </h2>
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">单身程序员的小窝</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/机器学习/"><i class="fa "></i>MachineLearning</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/深度学习/"><i class="fa "></i>DeepLearning</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/强化学习/"><i class="fa "></i>Reinforcement learning</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tools/"><i class="fa "></i>Tools</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>History</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="K-Means">
            
	            K-Means
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/Machine-Learning/">Machine Learning</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/02/15</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="电影评分的-k-均值聚类"><a href="#电影评分的-k-均值聚类" class="headerlink" title="电影评分的 k 均值聚类"></a>电影评分的 k 均值聚类</h1><p>假设你是 Netflix 的一名数据分析师，你想要根据用户对不同电影的评分研究用户在电影品位上的相似和不同之处。了解这些评分对用户电影推荐系统有帮助吗？我们来研究下这方面的数据。</p>
<p>我们将使用的数据来自精彩的 <a href="https://movielens.org/" target="_blank" rel="noopener">MovieLens</a> <a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">用户评分数据集</a>。我们稍后将在 notebook 中查看每个电影评分，先看看不同类型之间的评分比较情况。</p>
<h2 id="数据集概述"><a href="#数据集概述" class="headerlink" title="数据集概述"></a>数据集概述</h2><p>该数据集有两个文件。我们将这两个文件导入 pandas dataframe 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy.sparse <span class="keyword">import</span> csr_matrix</span><br><span class="line"><span class="keyword">import</span> helper</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import the Movies dataset</span></span><br><span class="line">movies = pd.read_csv(<span class="string">'ml-latest-small/movies.csv'</span>)</span><br><span class="line">movies.head()</span><br></pre></td></tr></table></figure>
<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }
    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>movieId</th>
      <th>title</th>
      <th>genres</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>Toy Story (1995)</td>
      <td>Adventure|Animation|Children|Comedy|Fantasy</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>Jumanji (1995)</td>
      <td>Adventure|Children|Fantasy</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>Grumpier Old Men (1995)</td>
      <td>Comedy|Romance</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>Waiting to Exhale (1995)</td>
      <td>Comedy|Drama|Romance</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>Father of the Bride Part II (1995)</td>
      <td>Comedy</td>
    </tr>
  </tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the ratings dataset</span></span><br><span class="line">ratings = pd.read_csv(<span class="string">'ml-latest-small/ratings.csv'</span>)</span><br><span class="line">ratings.head()</span><br></pre></td></tr></table></figure>

<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>userId</th>
      <th>movieId</th>
      <th>rating</th>
      <th>timestamp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>31</td>
      <td>2.5</td>
      <td>1260759144</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1029</td>
      <td>3.0</td>
      <td>1260759179</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>1061</td>
      <td>3.0</td>
      <td>1260759182</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1129</td>
      <td>2.0</td>
      <td>1260759185</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>1172</td>
      <td>4.0</td>
      <td>1260759205</td>
    </tr>
  </tbody>
</table>
</div>



<p>现在我们已经知道数据集的结构，每个表格中有多少条记录。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'The dataset contains: '</span>, len(ratings), <span class="string">' ratings of '</span>, len(movies), <span class="string">' movies.'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>The dataset contains:  100004  ratings of  9125  movies.
</code></pre><h2 id="爱情片与科幻片"><a href="#爱情片与科幻片" class="headerlink" title="爱情片与科幻片"></a>爱情片与科幻片</h2><p>我们先查看一小部分用户，并看看他们喜欢什么类型的电影。我们将大部分数据预处理过程都隐藏在了辅助函数中，并重点研究聚类概念。在完成此 notebook 后，建议你快速浏览下 helper.py，了解这些辅助函数是如何实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Calculate the average rating of romance and scifi movies</span></span><br><span class="line"></span><br><span class="line">genre_ratings = helper.get_genre_ratings(ratings, movies, [<span class="string">'Romance'</span>, <span class="string">'Sci-Fi'</span>], [<span class="string">'avg_romance_rating'</span>, <span class="string">'avg_scifi_rating'</span>])</span><br><span class="line">genre_ratings.head()</span><br></pre></td></tr></table></figure>
<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>avg_romance_rating</th>
      <th>avg_scifi_rating</th>
    </tr>
    <tr>
      <th>userId</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>3.50</td>
      <td>2.40</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3.59</td>
      <td>3.80</td>
    </tr>
    <tr>
      <th>3</th>
      <td>3.65</td>
      <td>3.14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.50</td>
      <td>4.26</td>
    </tr>
    <tr>
      <th>5</th>
      <td>4.08</td>
      <td>4.00</td>
    </tr>
  </tbody>
</table>
</div>



<p>函数 <code>get_genre_ratings</code> 计算了每位用户对所有爱情片和科幻片的平均评分。我们对数据集稍微进行偏倚，删除同时喜欢科幻片和爱情片的用户，使聚类能够将他们定义为更喜欢其中一种类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">biased_dataset = helper.bias_genre_rating_dataset(genre_ratings, <span class="number">3.2</span>, <span class="number">2.5</span>)</span><br><span class="line"></span><br><span class="line">print( <span class="string">"Number of records: "</span>, len(biased_dataset))</span><br><span class="line">biased_dataset.head()</span><br></pre></td></tr></table></figure>
<pre><code>Number of records:  183
</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>userId</th>
      <th>avg_romance_rating</th>
      <th>avg_scifi_rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>3.50</td>
      <td>2.40</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>3.65</td>
      <td>3.14</td>
    </tr>
    <tr>
      <th>2</th>
      <td>6</td>
      <td>2.90</td>
      <td>2.75</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7</td>
      <td>2.93</td>
      <td>3.36</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12</td>
      <td>2.89</td>
      <td>2.62</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以看出我们有 183 位用户，对于每位用户，我们都得出了他们对看过的爱情片和科幻片的平均评分。</p>
<p>我们来绘制该数据集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line">helper.draw_scatterplot(biased_dataset[<span class="string">'avg_scifi_rating'</span>],<span class="string">'Avg scifi rating'</span>, biased_dataset[<span class="string">'avg_romance_rating'</span>], <span class="string">'Avg romance rating'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164524473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>我们可以在此样本中看到明显的偏差（我们故意创建的）。如果使用 k 均值将样本分成两组，效果如何？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Let's turn our dataset into a list</span></span><br><span class="line">X = biased_dataset[[<span class="string">'avg_scifi_rating'</span>,<span class="string">'avg_romance_rating'</span>]].values</span><br></pre></td></tr></table></figure>
<ul>
<li>导入 <a href="http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html" target="_blank" rel="noopener">KMeans</a></li>
<li>通过 n_clusters = 2 准备 KMeans</li>
<li>将数据集 <strong>X</strong> 传递给 KMeans 的 fit_predict 方法，并将聚类标签放入 <em>predictions</em></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Import KMeans</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create an instance of KMeans to find two clusters</span></span><br><span class="line">kmeans_1 = KMeans(n_clusters = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use fit_predict to cluster the dataset</span></span><br><span class="line">predictions = kmeans_1.fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">helper.draw_clusters(biased_dataset, predictions)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164541299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>可以看出分组的依据主要是每个人对爱情片的评分高低。如果爱情片的平均评分超过 3 星，则属于第一组，否则属于另一组。</p>
<p>如果分成三组，会发生什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create an instance of KMeans to find three clusters</span></span><br><span class="line">kmeans_2 = KMeans(n_clusters = <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use fit_predict to cluster the dataset</span></span><br><span class="line">predictions_2 = kmeans_2.fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">helper.draw_clusters(biased_dataset, predictions_2)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164554198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>现在平均科幻片评分开始起作用了，分组情况如下所示：</p>
<ul>
<li>喜欢爱情片但是不喜欢科幻片的用户</li>
<li>喜欢科幻片但是不喜欢爱情片的用户</li>
<li>即喜欢科幻片又喜欢爱情片的用户</li>
</ul>
<p>再添加一组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create an instance of KMeans to find four clusters</span></span><br><span class="line">kmeans_3 = KMeans(n_clusters = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use fit_predict to cluster the dataset</span></span><br><span class="line">predictions_3 = kmeans_3.fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot</span></span><br><span class="line">helper.draw_clusters(biased_dataset, predictions_3)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164605843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>可以看出将数据集分成的聚类越多，每个聚类中用户的兴趣就相互之间越相似。</p>
<h2 id="选择-K"><a href="#选择-K" class="headerlink" title="选择 K"></a>选择 K</h2><p>我们可以将数据点拆分为任何数量的聚类。对于此数据集来说，正确的聚类数量是多少？</p>
<p>可以通过<a href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set" target="_blank" rel="noopener">多种</a>方式选择聚类 k。我们将研究一种简单的方式，叫做“肘部方法”。肘部方法会绘制 k 的上升值与使用该 k 值计算的总误差分布情况。</p>
<p>如何计算总误差？<br>一种方法是计算平方误差。假设我们要计算 k=2 时的误差。有两个聚类，每个聚类有一个“图心”点。对于数据集中的每个点，我们将其坐标减去所属聚类的图心。然后将差值结果取平方（以便消除负值），并对结果求和。这样就可以获得每个点的误差值。如果将这些误差值求和，就会获得 k=2 时所有点的总误差。</p>
<p>现在的一个任务是对每个 k（介于 1 到数据集中的元素数量之间）执行相同的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Choose the range of k values to test.</span></span><br><span class="line"><span class="comment"># We added a stride of 5 to improve performance. We don't need to calculate the error for every k value</span></span><br><span class="line">possible_k_values = range(<span class="number">2</span>, len(X)+<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate error values for all k values we're interested in</span></span><br><span class="line">errors_per_k = [helper.clustering_errors(k, X) <span class="keyword">for</span> k <span class="keyword">in</span> possible_k_values]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Optional: Look at the values of K vs the silhouette score of running K-means with that value of k</span></span><br><span class="line">list(zip(possible_k_values, errors_per_k))</span><br></pre></td></tr></table></figure>
<pre><code>[(2, 0.35588178764728251),
 (7, 0.37324118163771741),
 (12, 0.35650856326047475),
 (17, 0.3741137698024623),
 (22, 0.37718217339438476),
 (27, 0.36071909992215945),
 (32, 0.37104279808464452),
 (37, 0.3649882241766923),
 (42, 0.36895091450195883),
 (47, 0.37696003940733186),
 (52, 0.38716548900081571),
 (57, 0.35079775582937778),
 (62, 0.34916584233387205),
 (67, 0.34839937724907),
 (72, 0.34907390154971468),
 (77, 0.34837739216196456),
 (82, 0.3309353056966266),
 (87, 0.34005916910201761),
 (92, 0.32494553685658306),
 (97, 0.32418331059507227),
 (102, 0.31329160485165003),
 (107, 0.29407239955320186),
 (112, 0.27366896911138017),
 (117, 0.28906341363336779),
 (122, 0.27342563040040624),
 (127, 0.25219179857975438),
 (132, 0.25320773897416415),
 (137, 0.2412264569953621),
 (142, 0.21855949198498667),
 (147, 0.19924498428850082),
 (152, 0.18722856283659275),
 (157, 0.16447514022082693),
 (162, 0.14697529680439808),
 (167, 0.12609539969216882),
 (172, 0.096865005870864829),
 (177, 0.064230120163174503),
 (182, 0.054644808743169397)]
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Plot the each value of K vs. the silhouette score at that value</span></span><br><span class="line">fig, ax = plt.subplots(figsize=(<span class="number">16</span>, <span class="number">6</span>))</span><br><span class="line">ax.set_xlabel(<span class="string">'K - number of clusters'</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">'Silhouette Score (higher is better)'</span>)</span><br><span class="line">ax.plot(possible_k_values, errors_per_k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ticks and grid</span></span><br><span class="line">xticks = np.arange(min(possible_k_values), max(possible_k_values)+<span class="number">1</span>, <span class="number">5.0</span>)</span><br><span class="line">ax.set_xticks(xticks, minor=<span class="keyword">False</span>)</span><br><span class="line">ax.set_xticks(xticks, minor=<span class="keyword">True</span>)</span><br><span class="line">ax.xaxis.grid(<span class="keyword">True</span>, which=<span class="string">'both'</span>)</span><br><span class="line">yticks = np.arange(round(min(errors_per_k), <span class="number">2</span>), max(errors_per_k), <span class="number">.05</span>)</span><br><span class="line">ax.set_yticks(yticks, minor=<span class="keyword">False</span>)</span><br><span class="line">ax.set_yticks(yticks, minor=<span class="keyword">True</span>)</span><br><span class="line">ax.yaxis.grid(<span class="keyword">True</span>, which=<span class="string">'both'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164621119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>看了该图后发现，合适的 k 值包括 7、22、27、32 等（每次运行时稍微不同）。聚类  (k) 数量超过该范围将开始导致糟糕的聚类情况（根据轮廓分数）</p>
<p>我会选择 k=7，因为更容易可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create an instance of KMeans to find seven clusters</span></span><br><span class="line">kmeans_4 = KMeans(n_clusters=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use fit_predict to cluster the dataset</span></span><br><span class="line">predictions_4 = kmeans_4.fit_predict(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">helper.draw_clusters(biased_dataset, predictions_4, cmap=<span class="string">'Accent'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164634463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>注意：当你尝试绘制更大的 k 值（超过 10）时，需要确保你的绘制库没有对聚类重复使用相同的颜色。对于此图，我们需要使用 <a href="https://matplotlib.org/examples/color/colormaps_reference.html" target="_blank" rel="noopener">matplotlib colormap</a> ‘Accent’，因为其他色图要么颜色之间的对比度不强烈，要么在超过 8 个或 10 个聚类后会重复利用某些颜色。</p>
<h2 id="再加入动作片类型"><a href="#再加入动作片类型" class="headerlink" title="再加入动作片类型"></a>再加入动作片类型</h2><p>到目前为止，我们只查看了用户如何对爱情片和科幻片进行评分。我们再添加另一种类型，看看加入动作片类型后效果如何。</p>
<p>现在数据集如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">biased_dataset_3_genres = helper.get_genre_ratings(ratings, movies, </span><br><span class="line">                                                     [<span class="string">'Romance'</span>, <span class="string">'Sci-Fi'</span>, <span class="string">'Action'</span>], </span><br><span class="line">                                                     [<span class="string">'avg_romance_rating'</span>, <span class="string">'avg_scifi_rating'</span>, <span class="string">'avg_action_rating'</span>])</span><br><span class="line">biased_dataset_3_genres = helper.bias_genre_rating_dataset(biased_dataset_3_genres, <span class="number">3.2</span>, <span class="number">2.5</span>).dropna()</span><br><span class="line"></span><br><span class="line">print( <span class="string">"Number of records: "</span>, len(biased_dataset_3_genres))</span><br><span class="line">biased_dataset_3_genres.head()</span><br></pre></td></tr></table></figure>
<pre><code>Number of records:  183
</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>userId</th>
      <th>avg_romance_rating</th>
      <th>avg_scifi_rating</th>
      <th>avg_action_rating</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>3.50</td>
      <td>2.40</td>
      <td>2.80</td>
    </tr>
    <tr>
      <th>1</th>
      <td>3</td>
      <td>3.65</td>
      <td>3.14</td>
      <td>3.47</td>
    </tr>
    <tr>
      <th>2</th>
      <td>6</td>
      <td>2.90</td>
      <td>2.75</td>
      <td>3.27</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7</td>
      <td>2.93</td>
      <td>3.36</td>
      <td>3.29</td>
    </tr>
    <tr>
      <th>4</th>
      <td>12</td>
      <td>2.89</td>
      <td>2.62</td>
      <td>3.21</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X_with_action = biased_dataset_3_genres[[<span class="string">'avg_scifi_rating'</span>,</span><br><span class="line">                                         <span class="string">'avg_romance_rating'</span>, </span><br><span class="line">                                         <span class="string">'avg_action_rating'</span>]].values</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Create an instance of KMeans to find seven clusters</span></span><br><span class="line">kmeans_5 = KMeans(n_clusters=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use fit_predict to cluster the dataset</span></span><br><span class="line">predictions_5 = kmeans_5.fit_predict(X_with_action)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot</span></span><br><span class="line">helper.draw_clusters_3d(biased_dataset_3_genres, predictions_5)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164652235.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>我们依然分别用 x 轴和 y 轴表示科幻片和爱情片。并用点的大小大致表示动作片评分情况（更大的点表示平均评分超过 3 颗星，更小的点表示不超过 3 颗星 ）。</p>
<p>可以看出添加类型后，用户的聚类分布发生了变化。为 k 均值提供的数据越多，每组中用户之间的兴趣越相似。但是如果继续这么绘制，我们将无法可视化二维或三维之外的情形。在下个部分，我们将使用另一种图表，看看多达 50 个维度的聚类情况。</p>
<h2 id="电影级别的聚类"><a href="#电影级别的聚类" class="headerlink" title="电影级别的聚类"></a>电影级别的聚类</h2><p>现在我们已经知道 k 均值会如何根据用户的类型品位对用户进行聚类，我们再进一步分析，看看用户对单个影片的评分情况。为此，我们将数据集构建成 userId 与用户对每部电影的评分形式。例如，我们来看看以下数据集子集：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Merge the two tables then pivot so we have Users X Movies dataframe</span></span><br><span class="line">ratings_title = pd.merge(ratings, movies[[<span class="string">'movieId'</span>, <span class="string">'title'</span>]], on=<span class="string">'movieId'</span> )</span><br><span class="line">user_movie_ratings = pd.pivot_table(ratings_title, index=<span class="string">'userId'</span>, columns= <span class="string">'title'</span>, values=<span class="string">'rating'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'dataset dimensions: '</span>, user_movie_ratings.shape, <span class="string">'\n\nSubset example:'</span>)</span><br><span class="line">user_movie_ratings.iloc[:<span class="number">6</span>, :<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<pre><code>dataset dimensions:  (671, 9064) 

Subset example:
</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>title</th>
      <th>"Great Performances" Cats (1998)</th>
      <th>$9.99 (2008)</th>
      <th>'Hellboy': The Seeds of Creation (2004)</th>
      <th>'Neath the Arizona Skies (1934)</th>
      <th>'Round Midnight (1986)</th>
      <th>'Salem's Lot (2004)</th>
      <th>'Til There Was You (1997)</th>
      <th>'burbs, The (1989)</th>
      <th>'night Mother (1986)</th>
      <th>(500) Days of Summer (2009)</th>
    </tr>
    <tr>
      <th>userId</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>6</th>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>4.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<p>NaN 值的优势表明了第一个问题。大多数用户没有看过大部分电影，并且没有为这些电影评分。这种数据集称为“稀疏”数据集，因为只有少数单元格有值。</p>
<p>为了解决这一问题，我们按照获得评分次数最多的电影和对电影评分次数最多的用户排序。这样可以形成更“密集”的区域，使我们能够查看数据集的顶部数据。</p>
<p>如果我们要选择获得评分次数最多的电影和对电影评分次数最多的用户，则如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">n_movies = <span class="number">30</span></span><br><span class="line">n_users = <span class="number">18</span></span><br><span class="line">most_rated_movies_users_selection = helper.sort_by_rating_density(user_movie_ratings, n_movies, n_users)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'dataset dimensions: '</span>, most_rated_movies_users_selection.shape)</span><br><span class="line">most_rated_movies_users_selection.head()</span><br></pre></td></tr></table></figure>
<pre><code>dataset dimensions:  (18, 30)
</code></pre><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>title</th>
      <th>Forrest Gump (1994)</th>
      <th>Pulp Fiction (1994)</th>
      <th>Shawshank Redemption, The (1994)</th>
      <th>Silence of the Lambs, The (1991)</th>
      <th>Star Wars: Episode IV - A New Hope (1977)</th>
      <th>Jurassic Park (1993)</th>
      <th>Matrix, The (1999)</th>
      <th>Toy Story (1995)</th>
      <th>Schindler's List (1993)</th>
      <th>Terminator 2: Judgment Day (1991)</th>
      <th>...</th>
      <th>Dances with Wolves (1990)</th>
      <th>Fight Club (1999)</th>
      <th>Usual Suspects, The (1995)</th>
      <th>Seven (a.k.a. Se7en) (1995)</th>
      <th>Lion King, The (1994)</th>
      <th>Godfather, The (1972)</th>
      <th>Lord of the Rings: The Fellowship of the Ring, The (2001)</th>
      <th>Apollo 13 (1995)</th>
      <th>True Lies (1994)</th>
      <th>Twelve Monkeys (a.k.a. 12 Monkeys) (1995)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>29</th>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>...</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>2.0</td>
    </tr>
    <tr>
      <th>508</th>
      <td>4.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>4.5</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>2.0</td>
      <td>...</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>3.5</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>3.0</td>
      <td>2.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>14</th>
      <td>1.0</td>
      <td>5.0</td>
      <td>2.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>2.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>...</td>
      <td>3.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>4.0</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>72</th>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>4.5</td>
      <td>4.0</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>3.0</td>
      <td>...</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>3.5</td>
      <td>3.0</td>
      <td>5.0</td>
    </tr>
    <tr>
      <th>653</th>
      <td>4.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>...</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>4.5</td>
      <td>5.0</td>
      <td>5.0</td>
      <td>4.0</td>
      <td>5.0</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 30 columns</p>
</div>



<p>这样更好分析。我们还需要指定一个可视化这些评分的良好方式，以便在查看更庞大的子集时能够直观地识别这些评分（稍后变成聚类）。</p>
<p>我们使用颜色代替评分数字：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helper.draw_movies_heatmap(most_rated_movies_users_selection)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2018110916471948.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>每列表示一部电影。每行表示一位用户。单元格的颜色根据图表右侧的刻度表示用户对该电影的评分情况。</p>
<p>注意到某些单元格是白色吗？表示相应用户没有对该电影进行评分。在现实中进行聚类时就会遇到这种问题。与一开始经过整理的示例不同，现实中的数据集经常比较稀疏，数据集中的部分单元格没有值。这样的话，直接根据电影评分对用户进行聚类不太方便，因为 k 均值通常不喜欢缺失值。</p>
<p>为了提高性能，我们将仅使用 1000 部电影的评分（数据集中一共有 9000 部以上）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user_movie_ratings =  pd.pivot_table(ratings_title, index=<span class="string">'userId'</span>, columns= <span class="string">'title'</span>, values=<span class="string">'rating'</span>)</span><br><span class="line">most_rated_movies_1k = helper.get_most_rated_movies(user_movie_ratings, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>为了使 sklearn 对像这样缺少值的数据集运行 k 均值聚类，我们首先需要将其转型为<a href="https://docs.scipy.org/doc/scipy-0.19.0/reference/generated/scipy.sparse.csr_matrix.html" target="_blank" rel="noopener">稀疏 csr 矩阵</a>类型（如 SciPi 库中所定义）。</p>
<p>要从 pandas dataframe 转换为稀疏矩阵，我们需要先转换为 SparseDataFrame，然后使用 pandas 的 <code>to_coo()</code> 方法进行转换。</p>
<p>注意：只有较新版本的 pandas 具有<code>to_coo()</code>。如果你在下个单元格中遇到问题，确保你的 pandas 是最新版本。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sparse_ratings = csr_matrix(pd.SparseDataFrame(most_rated_movies_1k).to_coo())</span><br></pre></td></tr></table></figure>
<h2 id="我们来聚类吧！"><a href="#我们来聚类吧！" class="headerlink" title="我们来聚类吧！"></a>我们来聚类吧！</h2><p>对于 k 均值，我们需要指定 k，即聚类数量。我们随意地尝试 k=20（选择 k 的更佳方式如上述肘部方法所示。但是，该方法需要一定的运行时间。):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 20 clusters</span></span><br><span class="line">predictions = KMeans(n_clusters=<span class="number">20</span>, algorithm=<span class="string">'full'</span>).fit_predict(sparse_ratings)</span><br></pre></td></tr></table></figure>
<p>为了可视化其中一些聚类，我们需要将每个聚类绘制成热图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">max_users = <span class="number">70</span></span><br><span class="line">max_movies = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">clustered = pd.concat([most_rated_movies_1k.reset_index(), pd.DataFrame(&#123;<span class="string">'group'</span>:predictions&#125;)], axis=<span class="number">1</span>)</span><br><span class="line">helper.draw_movie_clusters(clustered, max_users, max_movies)</span><br></pre></td></tr></table></figure>
<pre><code>cluster # 7
# of users in cluster: 276. # of users in plot: 70
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164732568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 16
# of users in cluster: 64. # of users in plot: 64
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164744447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 0
# of users in cluster: 26. # of users in plot: 26
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164755257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 2
# of users in cluster: 72. # of users in plot: 70
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164807895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 6
# of users in cluster: 17. # of users in plot: 17
</code></pre><p><img src="https://img-blog.csdnimg.cn/2018110916482043.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 3
# of users in cluster: 37. # of users in plot: 37
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164831735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 11
# of users in cluster: 12. # of users in plot: 12
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164842611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 18
# of users in cluster: 35. # of users in plot: 35
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164853952.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 9
# of users in cluster: 55. # of users in plot: 55
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164905955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 8
# of users in cluster: 27. # of users in plot: 27
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164919664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<pre><code>cluster # 15
# of users in cluster: 15. # of users in plot: 15
</code></pre><p><img src="https://img-blog.csdnimg.cn/20181109164944204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>需要注意以下几个事项：</p>
<ul>
<li>聚类中的评分越相似，你在该聚类中就越能发现颜色相似的<strong>垂直</strong>线。</li>
<li>在聚类中发现了非常有趣的规律：<ul>
<li>某些聚类比其他聚类更稀疏，其中的用户可能比其他聚类中的用户看的电影更少，评分的电影也更少。</li>
<li>某些聚类主要是黄色，汇聚了非常喜欢特定类型电影的用户。其他聚类主要是绿色或海蓝色，表示这些用户都认为某些电影可以评 2-3 颗星。</li>
<li>注意每个聚类中的电影有何变化。图表对数据进行了过滤，仅显示评分最多的电影，然后按照平均评分排序。</li>
<li>能找到《指环王》在每个聚类中位于哪个位置吗？《星球大战》呢？</li>
</ul>
</li>
<li>很容易发现具有相似颜色的<strong>水平</strong>线，表示评分变化不大的用户。这可能是 Netflix 从基于星级的评分切换到喜欢/不喜欢评分的原因之一。四颗星评分对不同的人来说，含义不同。</li>
<li>我们在可视化聚类时，采取了一些措施（过滤/排序/切片）。因为这种数据集比较“稀疏”，大多数单元格没有值（因为大部分用户没有看过大部分电影）。</li>
</ul>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>我们选择一个聚类和一位特定的用户，看看该聚类可以使我们执行哪些实用的操作。</p>
<p>首先选择一个聚类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Pick a cluster ID from the clusters above</span></span><br><span class="line">cluster_number = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's filter to only see the region of the dataset with the most number of values </span></span><br><span class="line">n_users = <span class="number">75</span></span><br><span class="line">n_movies = <span class="number">300</span></span><br><span class="line">cluster = clustered[clustered.group == cluster_number].drop([<span class="string">'index'</span>, <span class="string">'group'</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">cluster = helper.sort_by_rating_density(cluster, n_movies, n_users)</span><br><span class="line">helper.draw_movies_heatmap(cluster, axis_labels=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20181109164957936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTM0OTQw,size_16,color_FFFFFF,t_70" alt="png"></p>
<p>聚类中的实际评分如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster.fillna(<span class="string">''</span>).head()</span><br></pre></td></tr></table></figure>
<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Amadeus (1984)</th>
      <th>Annie Hall (1977)</th>
      <th>One Flew Over the Cuckoo's Nest (1975)</th>
      <th>Fargo (1996)</th>
      <th>Cool Hand Luke (1967)</th>
      <th>Chinatown (1974)</th>
      <th>North by Northwest (1959)</th>
      <th>Citizen Kane (1941)</th>
      <th>Wizard of Oz, The (1939)</th>
      <th>Raiders of the Lost Ark (Indiana Jones and the Raiders of the Lost Ark) (1981)</th>
      <th>...</th>
      <th>Sense and Sensibility (1995)</th>
      <th>Top Gun (1986)</th>
      <th>Flashdance (1983)</th>
      <th>Jerry Maguire (1996)</th>
      <th>Superman (1978)</th>
      <th>Abyss, The (1989)</th>
      <th>Devil in a Blue Dress (1995)</th>
      <th>Beetlejuice (1988)</th>
      <th>Dial M for Murder (1954)</th>
      <th>Broken Arrow (1996)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>5</td>
      <td>4</td>
      <td>4</td>
      <td>4</td>
      <td>5</td>
      <td></td>
      <td>4</td>
      <td>...</td>
      <td></td>
      <td>3</td>
      <td></td>
      <td>3</td>
      <td></td>
      <td>3</td>
      <td></td>
      <td></td>
      <td>4</td>
      <td>3</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.0</td>
      <td>4.0</td>
      <td>4.0</td>
      <td>4</td>
      <td>5</td>
      <td>5</td>
      <td>3</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>...</td>
      <td></td>
      <td>2</td>
      <td></td>
      <td>3</td>
      <td>2</td>
      <td></td>
      <td>4</td>
      <td>2</td>
      <td></td>
      <td>3</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5.0</td>
      <td>4.0</td>
      <td>5.0</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>5</td>
      <td>...</td>
      <td></td>
      <td></td>
      <td>3</td>
      <td>4</td>
      <td></td>
      <td></td>
      <td>5</td>
      <td></td>
      <td></td>
      <td>4</td>
    </tr>
    <tr>
      <th>8</th>
      <td>2.0</td>
      <td>5.0</td>
      <td>2.0</td>
      <td>5</td>
      <td>3</td>
      <td>5</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>3</td>
      <td>...</td>
      <td>4.5</td>
      <td></td>
      <td>2</td>
      <td>4</td>
      <td>3</td>
      <td></td>
      <td>3</td>
      <td>3</td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <th>10</th>
      <td>3.0</td>
      <td>4.0</td>
      <td>3.0</td>
      <td>4</td>
      <td>5</td>
      <td>4</td>
      <td>4</td>
      <td></td>
      <td>4</td>
      <td>5</td>
      <td>...</td>
      <td>5</td>
      <td></td>
      <td></td>
      <td></td>
      <td>4</td>
      <td>3</td>
      <td></td>
      <td>2</td>
      <td></td>
      <td></td>
    </tr>
  </tbody>
</table>
<p>5 rows × 300 columns</p>
</div>



<p>从表格中选择一个空白单元格。因为用户没有对该电影评分，所以是空白状态。能够预测她是否喜欢该电影吗？因为该用户属于似乎具有相似品位的用户聚类，我们可以计算该电影在此聚类中的平均评分，结果可以作为她是否喜欢该电影的合理预测依据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Fill in the name of the column/movie. e.g. 'Forrest Gump (1994)'</span></span><br><span class="line"><span class="comment"># Pick a movie from the table above since we're looking at a subset</span></span><br><span class="line">movie_name = <span class="string">'Forrest Gump (1994)'</span></span><br><span class="line"></span><br><span class="line">cluster[movie_name].mean()</span><br></pre></td></tr></table></figure>
<pre><code>3.6666666666666665
</code></pre><p>这就是我们关于她会如何对该电影进行评分的预测。</p>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>我们回顾下上一步的操作。我们使用 k 均值根据用户的评分对用户进行聚类。这样就形成了具有相似评分的用户聚类，因此通常具有相似的电影品位。基于这一点，当某个用户对某部电影没有评分时，我们对该聚类中所有其他用户的评分取平均值，该平均值就是我们猜测该用户对该电影的喜欢程度。</p>
<p>根据这一逻辑，如果我们计算该聚类中每部电影的平均分数，就可以判断该“品位聚类”对数据集中每部电影的喜欢程度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The average rating of 20 movies as rated by the users in the cluster</span></span><br><span class="line">cluster.mean().head(<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Amadeus (1984)                                                                    3.833333
Annie Hall (1977)                                                                 4.291667
One Flew Over the Cuckoo&#39;s Nest (1975)                                            4.208333
Fargo (1996)                                                                      4.454545
Cool Hand Luke (1967)                                                             4.636364
Chinatown (1974)                                                                  4.454545
North by Northwest (1959)                                                         4.409091
Citizen Kane (1941)                                                               4.681818
Wizard of Oz, The (1939)                                                          4.500000
Raiders of the Lost Ark (Indiana Jones and the Raiders of the Lost Ark) (1981)    4.272727
Butch Cassidy and the Sundance Kid (1969)                                         4.045455
Star Wars: Episode V - The Empire Strikes Back (1980)                             4.090909
Groundhog Day (1993)                                                              3.727273
Gone with the Wind (1939)                                                         4.272727
It&#39;s a Wonderful Life (1946)                                                      4.272727
2001: A Space Odyssey (1968)                                                      4.272727
Shawshank Redemption, The (1994)                                                  4.363636
Philadelphia Story, The (1940)                                                    4.409091
Bonnie and Clyde (1967)                                                           4.150000
To Kill a Mockingbird (1962)                                                      4.400000
dtype: float64
</code></pre><p>这对我们来说变得非常实用，因为现在我们可以使用它作为推荐引擎，使用户能够发现他们可能喜欢的电影。</p>
<p>当用户登录我们的应用时，现在我们可以向他们显示符合他们的兴趣品位的电影。推荐方式是选择聚类中该用户尚未评分的最高评分的电影。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">TODO:</span> Pick a user ID from the dataset</span></span><br><span class="line"><span class="comment"># Look at the table above outputted by the command "cluster.fillna('').head()" </span></span><br><span class="line"><span class="comment"># and pick one of the user ids (the first column in the table)</span></span><br><span class="line">user_id = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all this user's ratings</span></span><br><span class="line">user_2_ratings  = cluster.loc[user_id, :]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Which movies did they not rate? (We don't want to recommend movies they've already rated)</span></span><br><span class="line">user_2_unrated_movies =  user_2_ratings[user_2_ratings.isnull()]</span><br><span class="line"></span><br><span class="line"><span class="comment"># What are the ratings of these movies the user did not rate?</span></span><br><span class="line">avg_ratings = pd.concat([user_2_unrated_movies, cluster.mean()], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>).loc[:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let's sort by rating so the highest rated movies are presented first</span></span><br><span class="line">avg_ratings.sort_values(ascending=<span class="keyword">False</span>)[:<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<pre><code>Remains of the Day, The (1993)    4.666667
Saving Private Ryan (1998)        4.642857
African Queen, The (1951)         4.625000
Lone Star (1996)                  4.600000
Godfather: Part II, The (1974)    4.500000
Singin&#39; in the Rain (1952)        4.500000
My Cousin Vinny (1992)            4.500000
Raising Arizona (1987)            4.500000
Fargo (1996)                      4.454545
Rain Man (1988)                   4.400000
Full Metal Jacket (1987)          4.400000
Sense and Sensibility (1995)      4.375000
Fried Green Tomatoes (1991)       4.333333
Room with a View, A (1986)        4.300000
It&#39;s a Wonderful Life (1946)      4.272727
Dial M for Murder (1954)          4.250000
Laura (1944)                      4.250000
American Graffiti (1973)          4.250000
Much Ado About Nothing (1993)     4.250000
Ordinary People (1980)            4.250000
Name: 0, dtype: float64
</code></pre><p>这些是向用户推荐的前 20 部电影！</p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><ul>
<li>如果聚类中有一部电影只有一个评分，评分是 5 颗星。该电影在该聚类中的平均评分是多少？这会对我们的简单推荐引擎有何影响？你会如何调整推荐系统，以解决这一问题？</li>
</ul>
<h2 id="关于协同过滤的更多信息"><a href="#关于协同过滤的更多信息" class="headerlink" title="关于协同过滤的更多信息"></a>关于协同过滤的更多信息</h2><ul>
<li>这是一个简单的推荐引擎，展示了“协同过滤”的最基本概念。有很多可以改进该引擎的启发法和方法。为了推动在这一领域的发展，Netflix 设立了 <a href="https://en.wikipedia.org/wiki/Netflix_Prize" target="_blank" rel="noopener">Netflix 奖项</a> ，他们会向对 Netflix 的推荐算法做出最大改进的算法奖励 1,000,000 美元。</li>
<li>在 2009 年，“BellKor’s Pragmatic Chaos”团队获得了这一奖项。<a href="http://www.netflixprize.com/assets/GrandPrize2009_BPC_BigChaos.pdf" target="_blank" rel="noopener">这篇论文</a>介绍了他们采用的方式，其中包含大量方法。</li>
<li><a href="https://thenextweb.com/media/2012/04/13/remember-netflixs-1m-algorithm-contest-well-heres-why-it-didnt-use-the-winning-entry/" target="_blank" rel="noopener">Netflix 最终并没有使用这个荣获 1,000,000 美元奖励的算法</a>，因为他们采用了流式传输的方式，并产生了比电影评分要庞大得多的数据集——用户搜索了哪些内容？用户在此会话中试看了哪些其他电影？他们是否先看了一部电影，然后切换到了其他电影？这些新的数据点可以提供比评分本身更多的线索。</li>
</ul>
<h2 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h2><ul>
<li>该 notebook 显示了用户级推荐系统。我们实际上可以使用几乎一样的代码进行商品级推荐。例如亚马逊的“购买（评价或喜欢）此商品的客户也购买了（评价了或喜欢）以下商品：” 。我们可以在应用的每个电影页面显示这种推荐。为此，我们只需将数据集转置为“电影 X 用户”形状，然后根据评分之间的联系对电影（而不是用户）进行聚类。</li>
<li>我们从数据集 Movie Lens 中抽取了最小的子集，只包含 100,000 个评分。如果你想深入了解电影评分数据，可以查看他们的<a href="https://grouplens.org/datasets/movielens/" target="_blank" rel="noopener">完整数据集</a>，其中包含 2400 万个评分。</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Lucifer</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/02/15/Scorecard/" class="pre-post btn btn-default" title="Scorecard">
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Scorecard</span>
        </a>
    
    
        <a href="/2019/02/15/My-First-Post/" class="next-post btn btn-default" title="CNN网络图像识别">
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CNN网络图像识别</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
<div id="lv-container" data-id="city" data-uid="MTAyMC8zMzA1MS85NjEz">
  <script type="text/javascript">
     (function(d, s) {
         var j, e = d.getElementsByTagName(s)[0];
         if (typeof LivereTower === 'function') { return; }
         j = d.createElement(s);
         j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
         j.async = true;
         e.parentNode.insertBefore(j, e);
     })(document, 'script');
  </script>
</div>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#电影评分的-k-均值聚类"><span class="toc-text">电影评分的 k 均值聚类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据集概述"><span class="toc-text">数据集概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#爱情片与科幻片"><span class="toc-text">爱情片与科幻片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择-K"><span class="toc-text">选择 K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#再加入动作片类型"><span class="toc-text">再加入动作片类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#电影级别的聚类"><span class="toc-text">电影级别的聚类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我们来聚类吧！"><span class="toc-text">我们来聚类吧！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预测"><span class="toc-text">预测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#推荐"><span class="toc-text">推荐</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#练习："><span class="toc-text">练习：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关于协同过滤的更多信息"><span class="toc-text">关于协同过滤的更多信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#深入研究"><span class="toc-text">深入研究</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
        Total:
        <strong id="busuanzi_value_site_pv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
        &nbsp; | &nbsp;
        Visitors:
        <strong id="busuanzi_value_site_uv">
            <i class="fa fa-spinner fa-spin"></i>
        </strong>
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2018
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>




    <script src="/assets/tagcanvas.min.js?rev=2.9"></script>
    <script>
        var tagOption = {
            textColour: '#444', // 字体颜色
            outlineMethod: 'block', // 选中模式
            outlineColour: '#FFDAB9', // 选中模式的颜色
            interval: 30 || 30, // 动画帧之间的时间间隔，值越大，转动幅度越大
            textHeight: 13,
            outlineRadius: 3,
            freezeActive: true || '', // 选中的标签是否继续滚动
            frontSelect: true || '', // 不选标签云后部的标签
            initial: [0.1, -0.1],
            depth: 0.5,
            decel: 0.95,
            maxSpeed: 0.03,
            reverse: true || '', // 是否反向触发
            fadeIn: 500, // 进入动画时间
            wheelZoom: false || '' // 是否启用鼠标滚轮
        }
        TagCanvas.Start('tag-cloud-3d','',tagOption);
    </script>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/js/app.js?rev=@@hash"></script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>